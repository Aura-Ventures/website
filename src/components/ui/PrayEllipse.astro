---
interface Props {
  onAnimationFinished?: () => void;
  shouldAnimate?: boolean;
  ellipseSize?: { width: number; height: number };
}

const { onAnimationFinished, shouldAnimate = true, ellipseSize = { width: 300, height: 66 } } = Astro.props;

// 计算椭圆参数
const { width, height } = ellipseSize;
const cx = width / 2;
const cy = height / 2;
const rx = (width - 20) / 2;
const ry = (height - 10) / 2;

// 计算椭圆周长
const circumference = Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));

// 椭圆旋转角度
const ellipseRotation = -180 - 6.16;
const angle = Math.PI * 2 - 0.5;

// 计算星星位置
const alpha = (ellipseRotation * Math.PI) / 180;
const sparkleX = cx + rx * Math.cos(angle) * Math.cos(alpha) - ry * Math.sin(angle) * Math.sin(alpha);
const sparkleY = cy + rx * Math.cos(angle) * Math.sin(alpha) + ry * Math.sin(angle) * Math.cos(alpha);
---

<div
  class='animation-container'
  data-callback={onAnimationFinished?.toString()}
  data-should-animate={String(shouldAnimate)}
  data-ellipse-size={JSON.stringify(ellipseSize)}
  data-circumference={String(circumference)}
  data-sparkle-x={String(sparkleX)}
  data-sparkle-y={String(sparkleY)}
>
  <svg class='prayer-ellipse' viewBox={`0 0 ${width} ${height}`}>
    <defs>
      <linearGradient id='ellipseGradient' x1='0%' y1='0%' x2='0%' y2='100%'>
        <stop offset='0%' style='stop-color:#4F4F4F;stop-opacity:1'></stop>
        <stop offset='50%' style='stop-color:#4F4F4F;stop-opacity:0'></stop>
        <stop offset='100%' style='stop-color:#4F4F4F;stop-opacity:1'></stop>
      </linearGradient>
    </defs>
    <ellipse class='ellipse-path' cx={cx} cy={cy} rx={rx} ry={ry} transform={`rotate(${ellipseRotation}, ${cx}, ${cy})`}
    ></ellipse>
  </svg>
  <div class='star'></div>
</div>

<style>
  .animation-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .prayer-ellipse {
    width: 100%;
    height: 100%;
  }

  .ellipse-path {
    fill: none;
    stroke: url(#ellipseGradient);
    stroke-width: 1;
    opacity: 0;
  }

  .star {
    position: absolute;
    width: 26px;
    height: 26px;
    background-image: url('~/assets/images/sparkle.png');
    background-size: contain;
    opacity: 0;
  }

  @keyframes drawEllipse {
    to {
      stroke-dashoffset: 0;
    }
  }

  @keyframes fadeInStar {
    to {
      opacity: 1;
    }
  }
</style>

<script>
  // 动画控制逻辑
  function init() {
    const container = document.querySelector('.animation-container');
    const ellipse = document.querySelector('.ellipse-path') as SVGElement;
    const star = document.querySelector('.star') as HTMLElement;

    if (!container || !ellipse || !star) return;

    // 获取参数
    const shouldAnimate = container.getAttribute('data-should-animate') === 'true';
    const circumference = parseFloat(container.getAttribute('data-circumference') || '400');
    const sparkleX = parseFloat(container.getAttribute('data-sparkle-x') || '30');
    const sparkleY = parseFloat(container.getAttribute('data-sparkle-y') || '70');

    // 设置星星位置
    star.style.left = `${sparkleX - 13}px`;
    star.style.top = `${sparkleY - 13}px`;

    // 设置椭圆初始状态
    ellipse.style.strokeDasharray = `${circumference} ${circumference}`;
    ellipse.style.strokeDashoffset = String(circumference);

    const executeCallback = () => {
      const callbackStr = container.getAttribute('data-callback');
      if (callbackStr && callbackStr !== 'undefined') {
        try {
          const callback = new Function(`return ${callbackStr}`)();
          if (typeof callback === 'function') {
            callback();
          }
        } catch (e) {
          console.error('Failed to execute animation callback:', e);
        }
      }
    };

    if (!shouldAnimate) {
      // 如果不需要动画，直接设置最终状态
      ellipse.style.opacity = '1';
      ellipse.style.strokeDashoffset = '0';
      star.style.opacity = '1';
      executeCallback();
      return;
    }

    // 开始动画序列
    const startAnimation = () => {
      // 重置状态
      ellipse.style.opacity = '1';
      ellipse.style.strokeDashoffset = String(circumference);
      star.style.opacity = '0';

      // 椭圆描边动画 - 1秒
      ellipse.style.animation = 'drawEllipse 1s ease-in-out forwards';

      // 等待椭圆动画完成后的300ms，然后开始星星动画
      setTimeout(() => {
        star.style.animation = 'fadeInStar 0.3s ease-in-out forwards';

        // 星星动画完成后触发回调
        setTimeout(() => {
          executeCallback();
        }, 300);
      }, 1300); // 1000ms椭圆动画 + 300ms等待
    };

    startAnimation();
  }

  document.addEventListener('astro:page-load', () => {
    setTimeout(() => {
      init();
    }, 1000);
  });
</script>
